`timescale 1ns / 1ps

/* Tsinghua Advanced Networking Labs */

module tanlabs
#(
    parameter SIM = 0
)
(
    input wire RST,

    input wire gtclk_125_p,
    input wire gtclk_125_n,

    output wire [15:0] led,

    output wire uart_tx,
    input wire uart_rx,

    // SFP:
    // +-+-+
    // |0|2|
    // +-+-+
    // |1|3|
    // +-+-+
    input wire [3:0] sfp_rx_los,
    input wire [3:0] sfp_rx_p,
    input wire [3:0] sfp_rx_n,
    output wire [3:0] sfp_tx_dis,
    output wire [3:0] sfp_tx_p,
    output wire [3:0] sfp_tx_n,
    output wire [3:0] sfp_link,
    output wire [3:0] sfp_act,

    // I2C for SFP, unused.
    input wire sfp_sda,
    input wire sfp_scl,

    // SODIMM.
    inout [63:0] ddr3_dq,
    inout [7:0] ddr3_dqs_n,
    inout [7:0] ddr3_dqs_p,

    output [15:0] ddr3_addr,
    output [2:0] ddr3_ba,
    output ddr3_ras_n,
    output ddr3_cas_n,
    output ddr3_we_n,
    output ddr3_reset_n,
    output [0:0] ddr3_ck_p,
    output [0:0] ddr3_ck_n,
    output [0:0] ddr3_cke,
    output [0:0] ddr3_cs_n,
    output [7:0] ddr3_dm,
    output [0:0] ddr3_odt,

    // 15 位拨码开关，拨到“ON”时? 1
    input wire [15:0] dip_sw,  

    // BTN1~BTN4，按?开关，按下时为 1
    input wire [ 3:0] touch_btn
);

    localparam DATA_WIDTH = 64;
    localparam ID_WIDTH = 3;

    wire [4:0] debug_ingress_interconnect_ready;
    wire debug_datapath_fifo_ready;
    wire debug_egress_interconnect_ready;

    assign uart_tx = uart_rx;

    wire reset_in = RST;
    wire locked0, locked1;
    wire gtref_clk;  // 125MHz for the PHY/MAC IP core
    wire ref_clk;  // 200MHz for the PHY/MAC IP core
    wire mig_clk;  // 250MHz for the DRAM controller

    clk_wiz_0 clk_wiz_0_i(
        .ref_clk_out(ref_clk),
        .mig_clk_out(mig_clk),
        .reset(1'b0),
        .locked(locked0),
        .clk_in1(gtref_clk)
    );

    wire core_clk;  // README: This is for CPU and other components. You can change the frequency
    // by re-customizing the following IP core.

    clk_wiz_1 clk_wiz_1_i(
        .core_clk_out(core_clk),
        .reset(1'b0),
        .locked(locked1),
        .clk_in1(gtref_clk)
    );

    wire reset_not_sync = reset_in || !locked0 || !locked1;  // reset components

    wire mmcm_locked_out;
    wire rxuserclk_out;
    wire rxuserclk2_out;
    wire userclk_out;
    wire userclk2_out;
    wire pma_reset_out;
    wire gt0_qplloutclk_out;
    wire gt0_qplloutrefclk_out;
    wire gtref_clk_out;
    wire gtref_clk_buf_out;

    assign gtref_clk = gtref_clk_buf_out;
    wire eth_clk = userclk2_out;  // README: This is the main clock for frame processing logic,
    // 125MHz generated by the PHY/MAC IP core. 8 AXI-Streams are in this clock domain.

    wire reset_eth_not_sync = reset_in || !mmcm_locked_out;
    wire reset_eth;
    reset_sync reset_sync_reset_eth(
        .clk(eth_clk),
        .i(reset_eth_not_sync),
        .o(reset_eth)
    );

    wire [7:0] eth_tx8_data [0:4];
    wire eth_tx8_last [0:4];
    wire eth_tx8_ready [0:4];
    wire eth_tx8_user [0:4];
    wire eth_tx8_valid [0:4];

    wire [7:0] eth_rx8_data [0:4];
    wire eth_rx8_last [0:4];
    wire eth_rx8_user [0:4];
    wire eth_rx8_valid [0:4];

    genvar i;
    generate
        if (!SIM)
        begin : phy_mac_ip_cores
            // Instantiate 4 PHY/MAC IP cores.

            assign sfp_tx_dis[0] = 1'b0;
            axi_ethernet_0 axi_ethernet_0_i(
                .mac_irq(),
                .tx_mac_aclk(),
                .rx_mac_aclk(),
                .tx_reset(),
                .rx_reset(),

                .glbl_rst(reset_not_sync),

                .mmcm_locked_out(mmcm_locked_out),
                .rxuserclk_out(rxuserclk_out),
                .rxuserclk2_out(rxuserclk2_out),
                .userclk_out(userclk_out),
                .userclk2_out(userclk2_out),
                .pma_reset_out(pma_reset_out),
                .gt0_qplloutclk_out(gt0_qplloutclk_out),
                .gt0_qplloutrefclk_out(gt0_qplloutrefclk_out),
                .gtref_clk_out(gtref_clk_out),
                .gtref_clk_buf_out(gtref_clk_buf_out),

                .ref_clk(ref_clk),

                .s_axi_lite_resetn(~reset_eth),
                .s_axi_lite_clk(eth_clk),
                .s_axi_araddr(0),
                .s_axi_arready(),
                .s_axi_arvalid(0),
                .s_axi_awaddr(0),
                .s_axi_awready(),
                .s_axi_awvalid(0),
                .s_axi_bready(0),
                .s_axi_bresp(),
                .s_axi_bvalid(),
                .s_axi_rdata(),
                .s_axi_rready(0),
                .s_axi_rresp(),
                .s_axi_rvalid(),
                .s_axi_wdata(0),
                .s_axi_wready(),
                .s_axi_wvalid(0),

                .s_axis_tx_tdata(eth_tx8_data[0]),
                .s_axis_tx_tlast(eth_tx8_last[0]),
                .s_axis_tx_tready(eth_tx8_ready[0]),
                .s_axis_tx_tuser(eth_tx8_user[0]),
                .s_axis_tx_tvalid(eth_tx8_valid[0]),

                .m_axis_rx_tdata(eth_rx8_data[0]),
                .m_axis_rx_tlast(eth_rx8_last[0]),
                .m_axis_rx_tuser(eth_rx8_user[0]),
                .m_axis_rx_tvalid(eth_rx8_valid[0]),

                .s_axis_pause_tdata(0),
                .s_axis_pause_tvalid(0),

                .rx_statistics_statistics_data(),
                .rx_statistics_statistics_valid(),
                .tx_statistics_statistics_data(),
                .tx_statistics_statistics_valid(),

                .tx_ifg_delay(8'h00),
                .status_vector(),
                .signal_detect(~sfp_rx_los[0]),

                .sfp_rxn(sfp_rx_n[0]),
                .sfp_rxp(sfp_rx_p[0]),
                .sfp_txn(sfp_tx_n[0]),
                .sfp_txp(sfp_tx_p[0]),

                .mgt_clk_clk_n(gtclk_125_n),
                .mgt_clk_clk_p(gtclk_125_p)
            );

            for (i = 1; i < 4; i = i + 1)
            begin
                assign sfp_tx_dis[i] = 1'b0;
                axi_ethernet_noshared axi_ethernet_noshared_i(
                    .mac_irq(),
                    .tx_mac_aclk(),
                    .rx_mac_aclk(),
                    .tx_reset(),
                    .rx_reset(),

                    .glbl_rst(reset_not_sync),

                    .mmcm_locked(mmcm_locked_out),
                    .mmcm_reset_out(),
                    .rxuserclk(rxuserclk_out),
                    .rxuserclk2(rxuserclk2_out),
                    .userclk(userclk_out),
                    .userclk2(userclk2_out),
                    .pma_reset(pma_reset_out),
                    .rxoutclk(),
                    .txoutclk(),
                    .gt0_qplloutclk_in(gt0_qplloutclk_out),
                    .gt0_qplloutrefclk_in(gt0_qplloutrefclk_out),
                    .gtref_clk(gtref_clk_out),
                    .gtref_clk_buf(gtref_clk_buf_out),

                    .ref_clk(ref_clk),

                    .s_axi_lite_resetn(~reset_eth),
                    .s_axi_lite_clk(eth_clk),
                    .s_axi_araddr(0),
                    .s_axi_arready(),
                    .s_axi_arvalid(0),
                    .s_axi_awaddr(0),
                    .s_axi_awready(),
                    .s_axi_awvalid(0),
                    .s_axi_bready(0),
                    .s_axi_bresp(),
                    .s_axi_bvalid(),
                    .s_axi_rdata(),
                    .s_axi_rready(0),
                    .s_axi_rresp(),
                    .s_axi_rvalid(),
                    .s_axi_wdata(0),
                    .s_axi_wready(),
                    .s_axi_wvalid(0),

                    .s_axis_tx_tdata(eth_tx8_data[i]),
                    .s_axis_tx_tlast(eth_tx8_last[i]),
                    .s_axis_tx_tready(eth_tx8_ready[i]),
                    .s_axis_tx_tuser(eth_tx8_user[i]),
                    .s_axis_tx_tvalid(eth_tx8_valid[i]),

                    .m_axis_rx_tdata(eth_rx8_data[i]),
                    .m_axis_rx_tlast(eth_rx8_last[i]),
                    .m_axis_rx_tuser(eth_rx8_user[i]),
                    .m_axis_rx_tvalid(eth_rx8_valid[i]),

                    .s_axis_pause_tdata(0),
                    .s_axis_pause_tvalid(0),

                    .rx_statistics_statistics_data(),
                    .rx_statistics_statistics_valid(),
                    .tx_statistics_statistics_data(),
                    .tx_statistics_statistics_valid(),

                    .tx_ifg_delay(8'h00),
                    .status_vector(),
                    .signal_detect(~sfp_rx_los[i]),

                    .sfp_rxn(sfp_rx_n[i]),
                    .sfp_rxp(sfp_rx_p[i]),
                    .sfp_txn(sfp_tx_n[i]),
                    .sfp_txp(sfp_tx_p[i])
                );
            end
        end
        else
        begin : axis_models
            // For simulation.
            assign gtref_clk_buf_out = gtclk_125_p;
            assign userclk2_out = gtclk_125_p;
            assign mmcm_locked_out = 1'b1;

            assign sfp_tx_dis = 0;
            assign sfp_tx_p = 0;
            assign sfp_tx_n = 0;

            wire [DATA_WIDTH - 1:0] in_data;
            wire [DATA_WIDTH / 8 - 1:0] in_keep;
            wire in_last;
            wire [DATA_WIDTH / 8 - 1:0] in_user;
            wire [ID_WIDTH - 1:0] in_id;
            wire in_valid;
            wire in_ready;

            axis_model axis_model_i(
                .clk(eth_clk),
                .reset(reset_eth),

                .m_data(in_data),
                .m_keep(in_keep),
                .m_last(in_last),
                .m_user(in_user),
                .m_id(in_id),
                .m_valid(in_valid),
                .m_ready(in_ready)
            );

            wire [DATA_WIDTH - 1:0] sim_tx_data [0:3];
            wire [DATA_WIDTH / 8 - 1:0] sim_tx_keep [0:3];
            wire sim_tx_last [0:3];
            wire sim_tx_ready [0:3];
            wire [DATA_WIDTH / 8 - 1:0] sim_tx_user [0:3];
            wire sim_tx_valid [0:3];

            axis_interconnect_egress axis_interconnect_sim_in_i(
                .ACLK(eth_clk),
                .ARESETN(~reset_eth),

                .S00_AXIS_ACLK(eth_clk),
                .S00_AXIS_ARESETN(~reset_eth),
                .S00_AXIS_TVALID(in_valid),
                .S00_AXIS_TREADY(in_ready),
                .S00_AXIS_TDATA(in_data),
                .S00_AXIS_TKEEP(in_keep),
                .S00_AXIS_TLAST(in_last),
                .S00_AXIS_TDEST(in_id),
                .S00_AXIS_TUSER(in_user),

                .M00_AXIS_ACLK(eth_clk),
                .M00_AXIS_ARESETN(~reset_eth),
                .M00_AXIS_TVALID(sim_tx_valid[0]),
                .M00_AXIS_TREADY(sim_tx_ready[0]),
                .M00_AXIS_TDATA(sim_tx_data[0]),
                .M00_AXIS_TKEEP(sim_tx_keep[0]),
                .M00_AXIS_TLAST(sim_tx_last[0]),
                .M00_AXIS_TDEST(),
                .M00_AXIS_TUSER(sim_tx_user[0]),

                .M01_AXIS_ACLK(eth_clk),
                .M01_AXIS_ARESETN(~reset_eth),
                .M01_AXIS_TVALID(sim_tx_valid[1]),
                .M01_AXIS_TREADY(sim_tx_ready[1]),
                .M01_AXIS_TDATA(sim_tx_data[1]),
                .M01_AXIS_TKEEP(sim_tx_keep[1]),
                .M01_AXIS_TLAST(sim_tx_last[1]),
                .M01_AXIS_TDEST(),
                .M01_AXIS_TUSER(sim_tx_user[1]),

                .M02_AXIS_ACLK(eth_clk),
                .M02_AXIS_ARESETN(~reset_eth),
                .M02_AXIS_TVALID(sim_tx_valid[2]),
                .M02_AXIS_TREADY(sim_tx_ready[2]),
                .M02_AXIS_TDATA(sim_tx_data[2]),
                .M02_AXIS_TKEEP(sim_tx_keep[2]),
                .M02_AXIS_TLAST(sim_tx_last[2]),
                .M02_AXIS_TDEST(),
                .M02_AXIS_TUSER(sim_tx_user[2]),

                .M03_AXIS_ACLK(eth_clk),
                .M03_AXIS_ARESETN(~reset_eth),
                .M03_AXIS_TVALID(sim_tx_valid[3]),
                .M03_AXIS_TREADY(sim_tx_ready[3]),
                .M03_AXIS_TDATA(sim_tx_data[3]),
                .M03_AXIS_TKEEP(sim_tx_keep[3]),
                .M03_AXIS_TLAST(sim_tx_last[3]),
                .M03_AXIS_TDEST(),
                .M03_AXIS_TUSER(sim_tx_user[3]),

                .M04_AXIS_ACLK(eth_clk),
                .M04_AXIS_ARESETN(~reset_eth),
                .M04_AXIS_TVALID(),
                .M04_AXIS_TREADY(1'b1),
                .M04_AXIS_TDATA(),
                .M04_AXIS_TKEEP(),
                .M04_AXIS_TLAST(),
                .M04_AXIS_TDEST(),
                .M04_AXIS_TUSER(),

                .S00_DECODE_ERR()
            );

            for (i = 0; i < 4; i = i + 1)
            begin
                axis_dwidth_converter_64_8 axis_dwidth_converter_64_8_i(
                    .aclk(eth_clk),
                    .aresetn(~reset_eth),

                    .s_axis_tvalid(sim_tx_valid[i]),
                    .s_axis_tready(sim_tx_ready[i]),
                    .s_axis_tdata(sim_tx_data[i]),
                    .s_axis_tkeep(sim_tx_keep[i]),
                    .s_axis_tlast(sim_tx_last[i]),
                    .s_axis_tuser(sim_tx_user[i]),

                    .m_axis_tvalid(eth_rx8_valid[i]),
                    .m_axis_tready(debug_ingress_interconnect_ready[i]),  // FIXME
                    .m_axis_tdata(eth_rx8_data[i]),
                    .m_axis_tkeep(),
                    .m_axis_tlast(eth_rx8_last[i]),
                    .m_axis_tuser(eth_rx8_user[i])
                );
            end

            wire [DATA_WIDTH - 1:0] out_data;
            wire [DATA_WIDTH / 8 - 1:0] out_keep;
            wire out_last;
            wire [DATA_WIDTH / 8 - 1:0] out_user;
            wire [ID_WIDTH - 1:0] out_dest;
            wire out_valid;
            wire out_ready;

            axis_interconnect_ingress axis_interconnect_sim_out_i(
                .ACLK(eth_clk),
                .ARESETN(~reset_eth),

                .S00_AXIS_ACLK(eth_clk),
                .S00_AXIS_ARESETN(~reset_eth),
                .S00_AXIS_TVALID(eth_tx8_valid[0]),
                .S00_AXIS_TREADY(eth_tx8_ready[0]),
                .S00_AXIS_TDATA(eth_tx8_data[0]),
                .S00_AXIS_TKEEP(1'b1),
                .S00_AXIS_TLAST(eth_tx8_last[0]),
                .S00_AXIS_TID(3'd0),
                .S00_AXIS_TUSER(eth_tx8_user[0]),

                .S01_AXIS_ACLK(eth_clk),
                .S01_AXIS_ARESETN(~reset_eth),
                .S01_AXIS_TVALID(eth_tx8_valid[1]),
                .S01_AXIS_TREADY(eth_tx8_ready[1]),
                .S01_AXIS_TDATA(eth_tx8_data[1]),
                .S01_AXIS_TKEEP(1'b1),
                .S01_AXIS_TLAST(eth_tx8_last[1]),
                .S01_AXIS_TID(3'd1),
                .S01_AXIS_TUSER(eth_tx8_user[1]),

                .S02_AXIS_ACLK(eth_clk),
                .S02_AXIS_ARESETN(~reset_eth),
                .S02_AXIS_TVALID(eth_tx8_valid[2]),
                .S02_AXIS_TREADY(eth_tx8_ready[2]),
                .S02_AXIS_TDATA(eth_tx8_data[2]),
                .S02_AXIS_TKEEP(1'b1),
                .S02_AXIS_TLAST(eth_tx8_last[2]),
                .S02_AXIS_TID(3'd2),
                .S02_AXIS_TUSER(eth_tx8_user[2]),

                .S03_AXIS_ACLK(eth_clk),
                .S03_AXIS_ARESETN(~reset_eth),
                .S03_AXIS_TVALID(eth_tx8_valid[3]),
                .S03_AXIS_TREADY(eth_tx8_ready[3]),
                .S03_AXIS_TDATA(eth_tx8_data[3]),
                .S03_AXIS_TKEEP(1'b1),
                .S03_AXIS_TLAST(eth_tx8_last[3]),
                .S03_AXIS_TID(3'd3),
                .S03_AXIS_TUSER(eth_tx8_user[3]),

                .S04_AXIS_ACLK(eth_clk),
                .S04_AXIS_ARESETN(~reset_eth),
                .S04_AXIS_TVALID(1'b0),
                .S04_AXIS_TREADY(),
                .S04_AXIS_TDATA(0),
                .S04_AXIS_TKEEP(1'b1),
                .S04_AXIS_TLAST(1'b0),
                .S04_AXIS_TID(3'd4),
                .S04_AXIS_TUSER(1'b0),

                .M00_AXIS_ACLK(eth_clk),
                .M00_AXIS_ARESETN(~reset_eth),
                .M00_AXIS_TVALID(out_valid),
                .M00_AXIS_TREADY(out_ready),
                .M00_AXIS_TDATA(out_data),
                .M00_AXIS_TKEEP(out_keep),
                .M00_AXIS_TLAST(out_last),
                .M00_AXIS_TID(out_dest),
                .M00_AXIS_TUSER(out_user),

                .S00_ARB_REQ_SUPPRESS(0),
                .S01_ARB_REQ_SUPPRESS(0),
                .S02_ARB_REQ_SUPPRESS(0),
                .S03_ARB_REQ_SUPPRESS(0),
                .S04_ARB_REQ_SUPPRESS(0),

                .S00_FIFO_DATA_COUNT(),
                .S01_FIFO_DATA_COUNT(),
                .S02_FIFO_DATA_COUNT(),
                .S03_FIFO_DATA_COUNT(),
                .S04_FIFO_DATA_COUNT()
            );

            axis_receiver axis_receiver_i(
                .clk(eth_clk),
                .reset(reset_eth),

                .s_data(out_data),
                .s_keep(out_keep),
                .s_last(out_last),
                .s_user(out_user),
                .s_dest(out_dest),
                .s_valid(out_valid),
                .s_ready(out_ready)
            );
        end
    endgenerate

    wire [7:0] internal_tx_data;
    wire internal_tx_last;
    wire internal_tx_user;
    wire internal_tx_valid;
    assign eth_rx8_data[4] = internal_tx_data;
    assign eth_rx8_last[4] = internal_tx_last;
    assign eth_rx8_user[4] = internal_tx_user;
    assign eth_rx8_valid[4] = internal_tx_valid;

    wire [7:0] internal_rx_data = eth_tx8_data[4];
    wire internal_rx_last = eth_tx8_last[4];
    wire internal_rx_user = eth_tx8_user[4];
    wire internal_rx_valid = eth_tx8_valid[4];
    wire internal_rx_ready;
    assign eth_tx8_ready[4] = internal_rx_ready;

    // README: internal_tx_* and internal_rx_* are left for internal use.
    // You can connect them with your CPU to transfer frames between the router part and the CPU part,
    // and you may need to write some logic to receive from internal_rx_*, store data to some memory,
    // read data from some memory, and send to internal_tx_*.
    // You can also transfer frames in other ways.
    assign internal_tx_data = 0;
    assign internal_tx_last = 0;
    assign internal_tx_user = 0;
    assign internal_tx_valid = 0;
    assign internal_rx_ready = 0;

    wire [7:0] sfp_led;
    led_delayer led_delayer_i(
        .clk(eth_clk),
        .reset(reset_eth),
        .in_led({~sfp_rx_los[3],
                 ~sfp_rx_los[2],
                 ~sfp_rx_los[1],
                 ~sfp_rx_los[0],
                 (eth_tx8_valid[3] & eth_tx8_ready[3]) | eth_rx8_valid[3],
                 (eth_tx8_valid[2] & eth_tx8_ready[2]) | eth_rx8_valid[2],
                 (eth_tx8_valid[1] & eth_tx8_ready[1]) | eth_rx8_valid[1],
                 (eth_tx8_valid[0] & eth_tx8_ready[0]) | eth_rx8_valid[0]}),
        .out_led(sfp_led)
    );
    assign {sfp_link, sfp_act} = sfp_led;

    wire [DATA_WIDTH - 1:0] eth_rx_data;
    wire [DATA_WIDTH / 8 - 1:0] eth_rx_keep;
    wire eth_rx_last;
    wire [DATA_WIDTH / 8 - 1:0] eth_rx_user;
    wire [ID_WIDTH - 1:0] eth_rx_id;
    wire eth_rx_valid;

    axis_interconnect_ingress axis_interconnect_ingress_i(
        .ACLK(eth_clk),
        .ARESETN(~reset_eth),

        .S00_AXIS_ACLK(eth_clk),
        .S00_AXIS_ARESETN(~reset_eth),
        .S00_AXIS_TVALID(eth_rx8_valid[0]),
        .S00_AXIS_TREADY(debug_ingress_interconnect_ready[0]),
        .S00_AXIS_TDATA(eth_rx8_data[0]),
        .S00_AXIS_TKEEP(1'b1),
        .S00_AXIS_TLAST(eth_rx8_last[0]),
        .S00_AXIS_TID(3'd0),
        .S00_AXIS_TUSER(eth_rx8_user[0]),

        .S01_AXIS_ACLK(eth_clk),
        .S01_AXIS_ARESETN(~reset_eth),
        .S01_AXIS_TVALID(eth_rx8_valid[1]),
        .S01_AXIS_TREADY(debug_ingress_interconnect_ready[1]),
        .S01_AXIS_TDATA(eth_rx8_data[1]),
        .S01_AXIS_TKEEP(1'b1),
        .S01_AXIS_TLAST(eth_rx8_last[1]),
        .S01_AXIS_TID(3'd1),
        .S01_AXIS_TUSER(eth_rx8_user[1]),

        .S02_AXIS_ACLK(eth_clk),
        .S02_AXIS_ARESETN(~reset_eth),
        .S02_AXIS_TVALID(eth_rx8_valid[2]),
        .S02_AXIS_TREADY(debug_ingress_interconnect_ready[2]),
        .S02_AXIS_TDATA(eth_rx8_data[2]),
        .S02_AXIS_TKEEP(1'b1),
        .S02_AXIS_TLAST(eth_rx8_last[2]),
        .S02_AXIS_TID(3'd2),
        .S02_AXIS_TUSER(eth_rx8_user[2]),

        .S03_AXIS_ACLK(eth_clk),
        .S03_AXIS_ARESETN(~reset_eth),
        .S03_AXIS_TVALID(eth_rx8_valid[3]),
        .S03_AXIS_TREADY(debug_ingress_interconnect_ready[3]),
        .S03_AXIS_TDATA(eth_rx8_data[3]),
        .S03_AXIS_TKEEP(1'b1),
        .S03_AXIS_TLAST(eth_rx8_last[3]),
        .S03_AXIS_TID(3'd3),
        .S03_AXIS_TUSER(eth_rx8_user[3]),

        .S04_AXIS_ACLK(eth_clk),
        .S04_AXIS_ARESETN(~reset_eth),
        .S04_AXIS_TVALID(eth_rx8_valid[4]),
        .S04_AXIS_TREADY(debug_ingress_interconnect_ready[4]),
        .S04_AXIS_TDATA(eth_rx8_data[4]),
        .S04_AXIS_TKEEP(1'b1),
        .S04_AXIS_TLAST(eth_rx8_last[4]),
        .S04_AXIS_TID(3'd4),
        .S04_AXIS_TUSER(eth_rx8_user[4]),

        .M00_AXIS_ACLK(eth_clk),
        .M00_AXIS_ARESETN(~reset_eth),
        .M00_AXIS_TVALID(eth_rx_valid),
        .M00_AXIS_TREADY(1'b1),
        .M00_AXIS_TDATA(eth_rx_data),
        .M00_AXIS_TKEEP(eth_rx_keep),
        .M00_AXIS_TLAST(eth_rx_last),
        .M00_AXIS_TID(eth_rx_id),
        .M00_AXIS_TUSER(eth_rx_user),

        .S00_ARB_REQ_SUPPRESS(0),
        .S01_ARB_REQ_SUPPRESS(0),
        .S02_ARB_REQ_SUPPRESS(0),
        .S03_ARB_REQ_SUPPRESS(0),
        .S04_ARB_REQ_SUPPRESS(0),

        .S00_FIFO_DATA_COUNT(),
        .S01_FIFO_DATA_COUNT(),
        .S02_FIFO_DATA_COUNT(),
        .S03_FIFO_DATA_COUNT(),
        .S04_FIFO_DATA_COUNT()
    );

    wire [DATA_WIDTH - 1:0] dp_rx_data;
    wire [DATA_WIDTH / 8 - 1:0] dp_rx_keep;
    wire dp_rx_last;
    wire [DATA_WIDTH / 8 - 1:0] dp_rx_user;
    wire [ID_WIDTH - 1:0] dp_rx_id;
    wire dp_rx_valid;
    wire dp_rx_ready;

    frame_datapath_fifo
    #(
        .ENABLE(1),  // README: enable this if your datapath may block.
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH)
    )
    frame_datapath_fifo_i(
        .eth_clk(eth_clk),
        .reset(reset_eth),

        .s_data(eth_rx_data),
        .s_keep(eth_rx_keep),
        .s_last(eth_rx_last),
        .s_user(eth_rx_user),
        .s_id(eth_rx_id),
        .s_valid(eth_rx_valid),
        .s_ready(debug_datapath_fifo_ready),

        .m_data(dp_rx_data),
        .m_keep(dp_rx_keep),
        .m_last(dp_rx_last),
        .m_user(dp_rx_user),
        .m_id(dp_rx_id),
        .m_valid(dp_rx_valid),
        .m_ready(dp_rx_ready)
    );

    wire [DATA_WIDTH - 1:0] dp_tx_data;
    wire [DATA_WIDTH / 8 - 1:0] dp_tx_keep;
    wire dp_tx_last;
    wire [DATA_WIDTH / 8 - 1:0] dp_tx_user;
    wire [ID_WIDTH - 1:0] dp_tx_dest;
    wire dp_tx_valid;

    // Configuration of Address
    logic [47:0] mac_addr [3:0];          // 单播 MAC 地址
    logic [127:0] local_link_addr [3:0];  // 链路?地地址
    logic [127:0] gua [3:0];              // 全球单播地址

    logic [47:0] mac_addr_reg;            // MAC 地址配置寄存?
    logic [127:0] ipv6_addr_reg;          // IPv6 地址配置寄存?
    logic conf_finished;                  // 配置完成标志
    logic [3:0] addr_select;              // 当前正在配置的地址

    logic rst_btn, set_btn;

    // README: Instantiate your datapath.
    frame_datapath
    #(
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH)
    )
    frame_datapath_i(
        .eth_clk(eth_clk),
        .reset(reset_eth),

        .mac_addr(mac_addr),

        .s_data(dp_rx_data),
        .s_keep(dp_rx_keep),
        .s_last(dp_rx_last),
        .s_user(dp_rx_user),
        .s_id(dp_rx_id),
        .s_valid(dp_rx_valid),
        .s_ready(dp_rx_ready),

        .m_data(dp_tx_data),
        .m_keep(dp_tx_keep),
        .m_last(dp_tx_last),
        .m_user(dp_tx_user),
        .m_dest(dp_tx_dest),
        .m_valid(dp_tx_valid),
        .m_ready(1'b1),
        .local_link_addr(local_link_addr)

        // README: You will need to add some signals for your CPU to control the datapath,
        // or access the forwarding table or the address resolution cache.
    );

    wire [DATA_WIDTH - 1:0] eth_tx_data [0:4];
    wire [DATA_WIDTH / 8 - 1:0] eth_tx_keep [0:4];
    wire eth_tx_last [0:4];
    wire eth_tx_ready [0:4];
    wire [DATA_WIDTH / 8 - 1:0] eth_tx_user [0:4];
    wire eth_tx_valid [0:4];

    axis_interconnect_egress axis_interconnect_egress_i(
        .ACLK(eth_clk),
        .ARESETN(~reset_eth),

        .S00_AXIS_ACLK(eth_clk),
        .S00_AXIS_ARESETN(~reset_eth),
        .S00_AXIS_TVALID(dp_tx_valid),
        .S00_AXIS_TREADY(debug_egress_interconnect_ready),
        .S00_AXIS_TDATA(dp_tx_data),
        .S00_AXIS_TKEEP(dp_tx_keep),
        .S00_AXIS_TLAST(dp_tx_last),
        .S00_AXIS_TDEST(dp_tx_dest),
        .S00_AXIS_TUSER(dp_tx_user),

        .M00_AXIS_ACLK(eth_clk),
        .M00_AXIS_ARESETN(~reset_eth),
        .M00_AXIS_TVALID(eth_tx_valid[0]),
        .M00_AXIS_TREADY(eth_tx_ready[0]),
        .M00_AXIS_TDATA(eth_tx_data[0]),
        .M00_AXIS_TKEEP(eth_tx_keep[0]),
        .M00_AXIS_TLAST(eth_tx_last[0]),
        .M00_AXIS_TDEST(),
        .M00_AXIS_TUSER(eth_tx_user[0]),

        .M01_AXIS_ACLK(eth_clk),
        .M01_AXIS_ARESETN(~reset_eth),
        .M01_AXIS_TVALID(eth_tx_valid[1]),
        .M01_AXIS_TREADY(eth_tx_ready[1]),
        .M01_AXIS_TDATA(eth_tx_data[1]),
        .M01_AXIS_TKEEP(eth_tx_keep[1]),
        .M01_AXIS_TLAST(eth_tx_last[1]),
        .M01_AXIS_TDEST(),
        .M01_AXIS_TUSER(eth_tx_user[1]),

        .M02_AXIS_ACLK(eth_clk),
        .M02_AXIS_ARESETN(~reset_eth),
        .M02_AXIS_TVALID(eth_tx_valid[2]),
        .M02_AXIS_TREADY(eth_tx_ready[2]),
        .M02_AXIS_TDATA(eth_tx_data[2]),
        .M02_AXIS_TKEEP(eth_tx_keep[2]),
        .M02_AXIS_TLAST(eth_tx_last[2]),
        .M02_AXIS_TDEST(),
        .M02_AXIS_TUSER(eth_tx_user[2]),

        .M03_AXIS_ACLK(eth_clk),
        .M03_AXIS_ARESETN(~reset_eth),
        .M03_AXIS_TVALID(eth_tx_valid[3]),
        .M03_AXIS_TREADY(eth_tx_ready[3]),
        .M03_AXIS_TDATA(eth_tx_data[3]),
        .M03_AXIS_TKEEP(eth_tx_keep[3]),
        .M03_AXIS_TLAST(eth_tx_last[3]),
        .M03_AXIS_TDEST(),
        .M03_AXIS_TUSER(eth_tx_user[3]),

        .M04_AXIS_ACLK(eth_clk),
        .M04_AXIS_ARESETN(~reset_eth),
        .M04_AXIS_TVALID(eth_tx_valid[4]),
        .M04_AXIS_TREADY(eth_tx_ready[4]),
        .M04_AXIS_TDATA(eth_tx_data[4]),
        .M04_AXIS_TKEEP(eth_tx_keep[4]),
        .M04_AXIS_TLAST(eth_tx_last[4]),
        .M04_AXIS_TDEST(),
        .M04_AXIS_TUSER(eth_tx_user[4]),

        .S00_DECODE_ERR()
    );

    generate
        for (i = 0; i < 5; i = i + 1)
        begin
            egress_wrapper
            #(
                .DATA_WIDTH(DATA_WIDTH),
                .ID_WIDTH(ID_WIDTH)
            )
            egress_wrapper_i(
                .eth_clk(eth_clk),
                .reset(reset_eth),

                .s_data(eth_tx_data[i]),
                .s_keep(eth_tx_keep[i]),
                .s_last(eth_tx_last[i]),
                .s_user(eth_tx_user[i]),
                .s_valid(eth_tx_valid[i]),
                .s_ready(eth_tx_ready[i]),

                .m_data(eth_tx8_data[i]),
                .m_last(eth_tx8_last[i]),
                .m_user(eth_tx8_user[i]),
                .m_valid(eth_tx8_valid[i]),
                .m_ready(eth_tx8_ready[i])
            );
        end
    endgenerate

    led_delayer led_delayer_debug_i1(
        .clk(eth_clk),
        .reset(reset_eth),
        .in_led({1'b0, ~debug_egress_interconnect_ready,
                 ~debug_datapath_fifo_ready,
                 ~debug_ingress_interconnect_ready}),
        .out_led(led[7:0])
    );
    assign led[15:9] = 0;

    // README: DRAM Controller.
    localparam DRAM_READ = 3'b001;
    localparam DRAM_WRITE = 3'b000;

    wire init_calib_complete;
    wire dram_clk, reset_dram;
    wire [28:0] app_addr = 0;
    wire [2:0] app_cmd = DRAM_READ;
    wire app_en = 0;
    wire app_rdy;
    wire [511:0] app_wdf_data = 0;
    wire app_wdf_end = 0;
    wire app_wdf_wren = 0;
    wire [63:0] app_wdf_mask = 0;
    wire app_wdf_rdy;
    wire [511:0] app_rd_data;
    wire app_rd_data_valid;
    generate
        if (!SIM)
        begin : mig_ip_core
            mig_7series_0 u_mig_7series_0(
                .ddr3_addr(ddr3_addr),
                .ddr3_ba(ddr3_ba),
                .ddr3_cas_n(ddr3_cas_n),
                .ddr3_ck_n(ddr3_ck_n),
                .ddr3_ck_p(ddr3_ck_p),
                .ddr3_cke(ddr3_cke),
                .ddr3_ras_n(ddr3_ras_n),
                .ddr3_reset_n(ddr3_reset_n),
                .ddr3_we_n(ddr3_we_n),
                .ddr3_dq(ddr3_dq),
                .ddr3_dqs_n(ddr3_dqs_n),
                .ddr3_dqs_p(ddr3_dqs_p),
                .ddr3_cs_n(ddr3_cs_n),
                .ddr3_dm(ddr3_dm),
                .ddr3_odt(ddr3_odt),

                .ui_clk(dram_clk),
                .ui_clk_sync_rst(reset_dram),
                .app_addr({1'b0, app_addr}),
                .app_cmd(app_cmd),
                .app_en(app_en),
                .app_rdy(app_rdy),
                .app_wdf_data(app_wdf_data),
                .app_wdf_end(app_wdf_end),
                .app_wdf_wren(app_wdf_wren),
                .app_wdf_mask(app_wdf_mask),
                .app_wdf_rdy(app_wdf_rdy),
                .app_rd_data(app_rd_data),
                .app_rd_data_end(),
                .app_rd_data_valid(app_rd_data_valid),

                .app_sr_req(1'b0),
                .app_ref_req(1'b0),
                .app_zq_req(1'b0),
                .app_sr_active(),
                .app_ref_ack(),
                .app_zq_ack(),

                .sys_clk_i(mig_clk),
                .clk_ref_i(ref_clk),
                .sys_rst(reset_not_sync),
                .init_calib_complete(init_calib_complete)
            );
        end
        else
        begin : mig_model
            assign dram_clk = eth_clk;
            assign reset_dram = reset_eth;
            assign init_calib_complete = 1'b1;

            mig_ui_model mig_ui_model_i(
                .clk(dram_clk),
                .reset(reset_dram),

                .app_addr(app_addr),
                .app_cmd(app_cmd),
                .app_en(app_en),
                .app_rdy(app_rdy),
                .app_wdf_data(app_wdf_data),
                .app_wdf_end(app_wdf_end),
                .app_wdf_wren(app_wdf_wren),
                .app_wdf_mask(app_wdf_mask),
                .app_wdf_rdy(app_wdf_rdy),
                .app_rd_data(app_rd_data),
                .app_rd_data_end(),
                .app_rd_data_valid(app_rd_data_valid)
            );
        end
    endgenerate
    assign led[8] = init_calib_complete;

    // README: You may use this to reset your CPU.
    wire reset_core;
    reset_sync reset_sync_reset_core(
        .clk(core_clk),
        .i(reset_not_sync),
        .o(reset_core)
    );

    // README: Your code here.

    always_ff @(posedge eth_clk) begin : addr_configuration
        if (reset_eth) begin
            for (int i = 0; i < 4; i = i + 1) begin
                mac_addr[i] <= 48'h0;
                gua[i] <= 128'h0;
            end
        end else begin
            if (conf_finished) begin
                case (addr_select)
                    4'b0000: mac_addr[0] <= mac_addr_reg;
                    4'b0010: mac_addr[1] <= mac_addr_reg;
                    4'b0100: mac_addr[2] <= mac_addr_reg;
                    4'b0110: mac_addr[3] <= mac_addr_reg;

                    4'b0001: gua[0] <= ipv6_addr_reg;
                    4'b0011: gua[1] <= ipv6_addr_reg;
                    4'b0101: gua[2] <= ipv6_addr_reg;
                    4'b0111: gua[3] <= ipv6_addr_reg;
                    default: ;
                endcase
            end
        end
    end

    addr_conf addr_conf_i(
        .clk(eth_clk),
        .rst_btn(rst_btn),

        .dip_sw(dip_sw[15:0]),
        .set_btn(set_btn),

        .mac_addr(mac_addr_reg),
        .ipv6_addr(gua_reg),

        .addr_select(addr_select),
        .finished(conf_finished)
    );

    // ? MAC 地址生成链路?地地址
    eui64 _eui64_0(
        .mac_addr(mac_addr[0]),
        .ipv6_addr(local_link_addr[0])
    );

    eui64 _eui64_1(
        .mac_addr(mac_addr[1]),
        .ipv6_addr(local_link_addr[1])
    );

    eui64 _eui64_2(
        .mac_addr(mac_addr[2]),
        .ipv6_addr(local_link_addr[2])
    );

    eui64 _eui64_3(
        .mac_addr(mac_addr[3]),
        .ipv6_addr(local_link_addr[3])
    );

    button_in rst_btn_in(
        .clk(eth_clk),
        .push_btn(touch_btn[0]),
        .trigger(rst_trigger)
    );
    button_in set_btn_in(
        .clk(eth_clk),
        .push_btn(touch_btn[3]),
        .trigger(set_btn)
    );
endmodule
